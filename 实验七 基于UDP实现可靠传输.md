# 实验七：基于 UDP 实现可靠传输

## 一、总述

本实验中，我们需要基于 **UDP** 实现一个**可靠传输协议**，该协议需保证 **UDP 报文段**能够在**包丢失、重复、失序**等特殊情况下**按序、可靠地交付**，我们暂且称该协议为 **RUDP (Reliable UDP)**。

保证报文在发送者和接收者之间可靠交付的方法有多种。在本实验中，我们给大家提供**协议接收端的代码**，该接收端收到数据包后会返回一个**累积确认 ACK**。大家要做的，是**实现发送端的代码**，保证该发送端发出的数据包能够可靠地交付给接收端。

我们定义 **RUDP 协议有四种消息类型**，分别是 **start**、**end**、**data** 和 **ack**。**start**、**end**、**data** 的消息格式如下：

```
start|<sequence number>|<data>|<checksum>
data|<sequence number>|<data>|<checksum>
end|<sequence number>|<data>|<checksum>
```

- **start 消息**用来初始化连接，该消息中的 **sequence number** 是收发双方使用的初始包序号。发送完 **start 消息**后，连接得以建立，接下来便会发送 **data 消息**传递数据。  
- **end 消息**用来断开连接，并且，**end 消息中携带了发送方发给接收方的最后一段数据**。

大家要实现的发送端应该能够接收并处理来自接收端的 **ack 消息**，**ack 消息的格式如下**：

```
ack|<sequence number>|<checksum>
```

需要注意，我们的 **RUDP 报文的最大长度是有限制的**。因为我们模拟以太网下的数据传输，以太网帧最大长度是 **1518 字节**，帧头部占 **18 字节**，IP 头部占 **20 字节**，UDP 头部占 **8 字节**，而我们的 **RUDP 是实现在 UDP 之上的**，因此 **RUDP 报文最大长度是 1472 字节**（包括类型、序列号、数据、校验和）。在实现发送端的代码时，如果待发送的文件过大，则需要将待发送的文件进行分割以“装进”RUDP 报文中。

上面所示的协议消息格式中，**尖括号（“<”和“>”）不属于消息的一部分**，并且注意在“|”两侧**没有空格**，在实现发送端代码时需要严格遵循我们规定的这种格式。

---

## 二、接收端说明

我们已经为大家写好了**接收端**，接收端在接收到数据包后，会发送 **ack 消息**给发送端，并且采用**累积确认**。一旦收到类型为 **start**、**end** 或 **data** 的消息，接收端就发送一个 **ack 消息**，该 **ack 消息的 sequence number 表示接收端期望接下来收到的数据包的序号**。

现在，如果接收端期望收到 **sequence number 为 N 的数据包**，那么接下来会有两种情况：

1. 如果接收端收到了一个 **sequence number 不为 N 的数据包**，它会发送 **“ack|N”**  
2. 如果接收端收到了一个 **sequence number 为 N 的数据包**，它会检查自己已按序收到的数据包中**序号最大的数据包**，假设该数据包的 **sequence number 为 M**，那么接收端会发送 **“ack|M+1”**

我们再通过两个例子具体看一下。假如发送端已经发送了数据包 **0、1 和 2**，但是 **1 在到达接收端之前丢了**，那么，接收端收到 **0** 后，会发送 **“ack|1”**，收到 **2** 后，仍然会发送 **“ack|1”**，之后，由于发送端重传了 **1**，接收端收到了 **1**，于是会发送 **“ack|3”**。

注意，如果某一时刻接收端期望收到的序号是 **N**，那么对于 **大于 N+4 的数据包，它都会丢掉**，这是因为接收端维护了一个**容纳 5 个数据包的接收窗口**，对于收到的但是未落入接收窗口的数据包，接收端会**直接丢掉**。接收窗口是可以滑动的，此时接收窗口为 **[N, N+4]**，如果接收端收到了 **N**，那么接收窗口变为 **[N+1, N+5]**。

如果接收端在 **10s 内没有收到任何数据包**，那么它会**自动断掉连接**。

---

## 三、发送端说明

发送端主要实现以下几点功能：

- 读取一个文件并将该文件通过 **UDP 套接字**发给指定的接收端  
- 如果文件过大，需将文件划分为大小合适的段后再装入 **RUDP 报文**  
- 通过 **start 消息**指定初始序号  
- 在每个报文后附加**校验和字段**（生成和验证校验和的函数已经在 **Checksum.py** 中提供）  
- 对于收到的**校验和无效的 ack 消息，直接丢掉**  
- 通过 **Go-Back-N 算法**实现可靠传输（记得接收端窗口大小为 **5**）

发送端应当在以下几种情况下仍然保证可靠传输：

- **丢包**：任意等级的丢包，包括 **100% 的丢包率**，也包括数据包或确认包的丢失  
- **失序**：数据包到达接收端的顺序是任意的  
- **重复**：数据包可能会重复发送给接收端

发送端通过以下命令调用：

```bash
python Sender.py -f <input file>
```

关于发送端的其他注意事项：

- 发送端应当设置一个 **500ms 的重传计时器**，对于超过 500ms 但是仍未收到确认消息的数据包，应当进行重传  
- 发送端应当设置一个**大小为 5 的发送窗口**  
- 发送端应当可以支持**任意类型的文件**（即可以发送图片/视频文件等等）

**仅实现 Go-Back-N 算法最高可获得 85 分**，如果**额外实现 Selective Acknowledgements（选择重传）**，最高可获得 **100 分**。

我们提供的 **Receiver.py** 代码已经支持选择重传，在运行的时候加上 **-k** 或 **--sack** 选项即可以选择重传模式运行。在选择重传模式下，接收端除了发送累积确认，还会发送**选择确认**，具体格式如下：

```
sack|<cum_ack;sack1,sack2,sack3,...>|<checksum>
```

- **cum_ack 是累积确认**，这跟 **ack 消息中的 sequence number 含义相同**  
- **cum_ack 之后，是一系列的选择确认**

比如，如果发送端发送了数据包 **0、1、2、3、4**，但是 **1 和 2 丢了**，下面的表格展示了当接收端依次接收到数据包的时候发送的 **sack 消息**：

| Packet Received | sack packet sent by the receiver       |
|------------------|----------------------------------------|
| 0                | `sack|1;|<checksum>`                  |
| 3                | `sack|1;3|<checksum>`                |
| 4                | `sack|1;3,4|<checksum>`              |

发送端和接收端都应当通过添加 **-k** 或 **--sack** 选项来开启选择确认模式：

- **发送端**：`python Sender.py -f <filename> -k`  
- **接收端**：`python Receiver.py -k`

我们给出了一个 **UnreliableSender** 作为样例 Sender，该 Sender 没有实现可靠传输，大家可以参考该 Sender 是如何继承 **BasicSender**，如何实现最基本的发包功能。

---

## 四、测试

**TestHarness.py** 为大家提供了一个测试框架（通过 `python TestHarness.py -s YourSender.py -r Receiver.py` 调用），**tests 目录下是具体的测试用例**。

- 目前的测试用例**只包含了模拟丢包的测试**  
- 大家需要自己编写**模拟失序和重复的测试用例**（以及其他大家可以想到的一些边界条件的测试用例）

如果实现了选择重传：
- 每种测试条件（丢包、失序、重复）**需要写两个测试类**，分别用来测 **Go-Back-N** 和 **选择重传**  
- 如果没有实现选择重传，每种测试条件**只需写一个测试类**

编写完测试用例后，需要在 **TestHarness.py 中的 `tests_to_run` 函数中加入该测试用例**，然后才能通过调用 TestHarness 运行该用例。

---

## 五、评分

- **实现了 Go-Back-N 算法**，测试用例编写正确无误，并且能通过**丢失、失序、重复三个测试用例**，**最高得 85 分**  
- 在以上基础上**正确实现了选择重传算法**，**最高可得 100 分**  
- **代码以及测试都将被实际执行进行验证**，请务必按如下格式保证代码和测试可执行：

### 1) 代码执行：

- **Go-Back-N 接收端**：`python Receiver.py`  
- **Go-Back-N 发送端**：`python Sender.py -f <file name>`  
- **选择重传接收端**：`python Receiver.py -k`  
- **选择重传发送端**：`python Sender.py -f <file name> -k`

### 2) 测试执行：

```bash
python TestHarness.py -s Sender.py -r Receiver.py
```